// Code generated by GripMock. DO NOT EDIT.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net"
	"net/http"

	"golang.org/x/net/context"
	"google.golang.org/grpc"
	_ "google.golang.org/grpc/encoding/gzip"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/reflection"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)
{{ range $package, $alias := .Dependencies }}
import {{$alias}} "{{$package}}"
{{end}}
const (
	TCP_ADDRESS  = "{{.GrpcAddr}}"
	HTTP_PORT = ":{{.AdminPort}}"
)

{{ range .Services }}
{{ template "services" . }}
{{ end }}

func main() {
	lis, err := net.Listen("tcp", TCP_ADDRESS)
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	s := grpc.NewServer()
	{{ range .Services }}
	{{ template "register_services" . }}
	{{ end }}

	reflection.Register(s)
	fmt.Println("Serving gRPC on tcp://" + TCP_ADDRESS)
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}

{{ template "find_stub" }}

{{ define "services" }}
type {{.Name}} struct{}

{{ template "methods" .}}
{{ end }}

{{ define "methods" }}
{{ range .Methods}}
	{{ if eq .MethodType "standard"}}
		{{ template "standard_method" .}}
	{{ else if eq .MethodType "server-stream"}}
		{{ template "server_stream_method" .}}
	{{ else if eq .MethodType "client-stream"}}
		{{ template "client_stream_method" .}}
	{{ else if eq .MethodType "bidirectional"}}
		{{ template "bidirectional_method" .}}
	{{ end }}
{{end}}
{{end}}

{{ define "standard_method" }}
func (s *{{.ServiceName}}) {{.Name}}(ctx context.Context, in *{{.Input}}) (*{{.Output}},error){
	out := &{{.Output}}{}
	headers, _ := metadata.FromIncomingContext(ctx)
	err := findStub(ctx, "{{.ServiceName}}", "{{.Name}}", headers, in, out)
	if err != nil {
		return nil, err
	}

	return out, err
}
{{ end }}

{{ define "server_stream_method" }}
func (s *{{.ServiceName}}) {{.Name}}(in *{{.Input}}, srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	out := &{{.Output}}{}
	headers, _ := metadata.FromIncomingContext(srv.Context())
	err := findStub(srv.Context(), "{{.ServiceName}}", "{{.Name}}", headers, in, out)
	if err != nil {
		return err
	}
	return srv.Send(out)
}
{{ end }}

{{ define "client_stream_method"}}
func (s *{{.ServiceName}}) {{.Name}}(srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	out := &{{.Output}}{}
	for {
		input,err := srv.Recv()
		if err == io.EOF {
			return srv.SendAndClose(out)
		}
		headers, _ := metadata.FromIncomingContext(srv.Context())
		err = findStub(srv.Context(), "{{.ServiceName}}","{{.Name}}", headers, input, out)
		if err != nil {
			return err
		}
	}
}
{{ end }}

{{ define "bidirectional_method"}}
func (s *{{.ServiceName}}) {{.Name}}(srv {{.SvcPackage}}{{.ServiceName}}_{{.Name}}Server) error {
	for {
		in, err := srv.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}

		headers, _ := metadata.FromIncomingContext(srv.Context())
		out := &{{.Output}}{}
		err = findStub(srv.Context(), "{{.ServiceName}}","{{.Name}}", headers, in, out)
		if err != nil {
			return err
		}

		if err := srv.Send(out); err != nil{
			return err
		}
	}
}
{{end}}


{{ define "register_services" }}
	{{.Package}}Register{{.Name}}Server(s, &{{.Name}}{})
{{ end }}

{{ define "find_stub" }}
type payload struct {
	Service string            `json:"service"`
	Method  string            `json:"method"`
	Data    interface{}       `json:"data"`
	Headers map[string]string `json:"headers"`
}

type response struct {
	Data  interface{} `json:"data"`
	Error string      `json:"error"`
	Code  *codes.Code `json:"code,omitempty"`
	Headers map[string]string `json:"headers,omitempty"`
}

func findStub(ctx context.Context, service, method string, headers metadata.MD, in, out proto.Message) error {
	url := fmt.Sprintf("http://localhost%s/find", HTTP_PORT)
	var headersMap map[string]string
	if headers != nil {
		headersMap = make(map[string]string)
		for header, values := range headers {
			headersMap[header] = values[0]
		}
	}

	pyl := payload{
		Service: service,
		Method:  method,
		Data:    in,
		Headers: headersMap,
	}
	byt, err := json.Marshal(pyl)
	if err != nil {
		return err
	}
	reader := bytes.NewReader(byt)
	resp, err := http.DefaultClient.Post(url, "application/json", reader)
	if err != nil {
		return fmt.Errorf("Error request to stub server %v",err)
	}

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf(string(body))
	}

	respRPC := new(response)
	err = json.NewDecoder(resp.Body).Decode(respRPC)
	if err != nil {
		return fmt.Errorf("decoding json response %v",err)
	}

	if respRPC.Error != "" || respRPC.Code != nil {
	    if respRPC.Code == nil {
	       abortedCode := codes.Aborted
	       respRPC.Code = &abortedCode
	    }
	    if *respRPC.Code != codes.OK {
		    return status.Error(*respRPC.Code, respRPC.Error)
		}
	}

    if respRPC.Headers != nil {
        md := metadata.New(respRPC.Headers)
        grpc.SetHeader(ctx, md)
    }

	data, _ := json.Marshal(respRPC.Data)
	return protojson.Unmarshal(data, out)
}
{{ end }}
